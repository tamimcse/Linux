diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h
index f805243..61df29c 100644
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@ -243,10 +243,14 @@ static inline struct fib_table *fib_get_table(struct net *net, u32 id)
 {
 	struct hlist_node *tb_hlist;
 	struct hlist_head *ptr;
+        struct hlist_head *fib = *this_cpu_ptr(net->ipv4.fib_table_hash_dup);
 
+
+//        *per_cpu_ptr(net->ipv4.fib_table_hash_dup, cpu)
+        
 	ptr = id == RT_TABLE_LOCAL ?
-		&net->ipv4.fib_table_hash[TABLE_LOCAL_INDEX] :
-		&net->ipv4.fib_table_hash[TABLE_MAIN_INDEX];
+		&fib[TABLE_LOCAL_INDEX] :
+		&fib[TABLE_MAIN_INDEX];
 
 	tb_hlist = rcu_dereference_rtnl(hlist_first_rcu(ptr));
 
diff --git a/include/net/netns/ipv4.h b/include/net/netns/ipv4.h
index 44668c2..c0cd6dd 100644
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@ -60,6 +60,7 @@ struct netns_ipv4 {
 	int			fib_num_tclassid_users;
 #endif
 	struct hlist_head	*fib_table_hash;
+        struct hlist_head  * __percpu	*fib_table_hash_dup;
 	bool			fib_offload_disabled;
 	struct sock		*fibnl;
 
diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c
index f05afaf..e0f1b23 100644
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@ -54,24 +54,43 @@
 static int __net_init fib4_rules_init(struct net *net)
 {
 	struct fib_table *local_table, *main_table;
-
-	main_table  = fib_trie_table(RT_TABLE_MAIN, NULL);
-	if (!main_table)
-		return -ENOMEM;
-
-	local_table = fib_trie_table(RT_TABLE_LOCAL, main_table);
-	if (!local_table)
-		goto fail;
-
-	hlist_add_head_rcu(&local_table->tb_hlist,
-				&net->ipv4.fib_table_hash[TABLE_LOCAL_INDEX]);
-	hlist_add_head_rcu(&main_table->tb_hlist,
-				&net->ipv4.fib_table_hash[TABLE_MAIN_INDEX]);
-	return 0;
-
-fail:
-	fib_free_table(main_table);
-	return -ENOMEM;
+        int cpu;
+
+        main_table  = fib_trie_table(RT_TABLE_MAIN, NULL);
+        if (!main_table)
+                return -ENOMEM;
+
+        local_table = fib_trie_table(RT_TABLE_LOCAL, main_table);
+        if (!local_table)
+                return -ENOMEM;
+
+        hlist_add_head_rcu(&local_table->tb_hlist,
+                                &net->ipv4.fib_table_hash[TABLE_LOCAL_INDEX]);
+        hlist_add_head_rcu(&main_table->tb_hlist,
+                                &net->ipv4.fib_table_hash[TABLE_MAIN_INDEX]);
+
+        net->ipv4.fib_table_hash_dup = alloc_percpu(struct hlist_head *);
+        if(!net->ipv4.fib_table_hash_dup)
+            return -ENOMEM;
+        
+        for_each_possible_cpu(cpu){
+            
+            main_table  = fib_trie_table(RT_TABLE_MAIN, NULL);
+            if (!main_table)
+                    return -ENOMEM;
+
+            local_table = fib_trie_table(RT_TABLE_LOCAL, main_table);
+            if (!local_table)
+                    return -ENOMEM;
+
+            struct hlist_head *fib = *per_cpu_ptr(net->ipv4.fib_table_hash_dup, cpu);
+           fib = kmalloc(sizeof (struct hlist_head) * FIB_TABLE_HASHSZ, GFP_KERNEL); 
+            
+            hlist_add_head(&local_table->tb_hlist, &fib[TABLE_LOCAL_INDEX]);
+            hlist_add_head(&main_table->tb_hlist, &fib[TABLE_MAIN_INDEX]);            
+            
+        }
+        return 0;
 }
 
 static bool fib4_has_custom_rules(struct net *net)
@@ -198,7 +217,7 @@ static void fib_flush(struct net *net)
 	unsigned int h;
 
 	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
-		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
+		struct hlist_head *head = &(*this_cpu_ptr(net->ipv4.fib_table_hash_dup)[h]);
 		struct hlist_node *tmp;
 		struct fib_table *tb;
 
@@ -803,7 +822,7 @@ static int inet_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)
 
 	for (h = s_h; h < FIB_TABLE_HASHSZ; h++, s_e = 0) {
 		e = 0;
-		head = &net->ipv4.fib_table_hash[h];
+		head = &(*this_cpu_ptr(net->ipv4.fib_table_hash_dup)[h]);
 		hlist_for_each_entry_rcu(tb, head, tb_hlist) {
 			if (e < s_e)
 				goto next;
@@ -1307,7 +1326,7 @@ static void ip_fib_net_exit(struct net *net)
 	 * references to data contained in the main table.
 	 */
 	for (i = FIB_TABLE_HASHSZ - 1; i >= 0; i--) {
-		struct hlist_head *head = &net->ipv4.fib_table_hash[i];
+		struct hlist_head *head = &(*this_cpu_ptr(net->ipv4.fib_table_hash_dup)[i]);
 		struct hlist_node *tmp;
 		struct fib_table *tb;
 
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 5530cd6..5afb108 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -1953,7 +1953,7 @@ void fib_notify(struct net *net, struct notifier_block *nb)
 	unsigned int h;
 
 	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
-		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
+		struct hlist_head *head = &(*this_cpu_ptr(net->ipv4.fib_table_hash_dup)[h]);
 		struct fib_table *tb;
 
 		hlist_for_each_entry_rcu(tb, head, tb_hlist)
@@ -2305,7 +2305,7 @@ static int fib_triestat_seq_show(struct seq_file *seq, void *v)
 		   LEAF_SIZE, TNODE_SIZE(0));
 
 	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
-		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
+		struct hlist_head *head = &(*this_cpu_ptr(net->ipv4.fib_table_hash_dup)[h]);
 		struct fib_table *tb;
 
 		hlist_for_each_entry_rcu(tb, head, tb_hlist) {
@@ -2348,7 +2348,7 @@ static struct key_vector *fib_trie_get_idx(struct seq_file *seq, loff_t pos)
 	unsigned int h;
 
 	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
-		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
+		struct hlist_head *head = &(*this_cpu_ptr(net->ipv4.fib_table_hash_dup)[h]);
 		struct fib_table *tb;
 
 		hlist_for_each_entry_rcu(tb, head, tb_hlist) {
@@ -2400,7 +2400,7 @@ static void *fib_trie_seq_next(struct seq_file *seq, void *v, loff_t *pos)
 
 	/* new hash chain */
 	while (++h < FIB_TABLE_HASHSZ) {
-		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
+		struct hlist_head *head = &(*this_cpu_ptr(net->ipv4.fib_table_hash_dup)[h]);
 		hlist_for_each_entry_rcu(tb, head, tb_hlist) {
 			n = fib_trie_get_first(iter, (struct trie *) tb->tb_data);
 			if (n)
