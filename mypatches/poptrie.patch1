diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h
index 81d0f21..e2a7b30 100644
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@ -25,6 +25,8 @@
 #include <linux/percpu.h>
 #include <linux/notifier.h>
 #include <linux/refcount.h>
+#include <linux/net.h>
+#include <linux/inet.h>
 
 struct fib_config {
 	u8			fc_dst_len;
@@ -197,6 +199,44 @@ struct fib_entry_notifier_info {
 	u32 tb_id;
 };
 
+/*Maximum number of next-hop*/
+#define NEXT_HOP_MAX 255
+
+struct next_hops {
+	/*Index of a next-hop is level16, level 24 and level 32 */	
+	struct net_device	*netdev_arr[NEXT_HOP_MAX];
+	/*Total number of next-hops*/
+	u8 count;
+};
+
+/* Internal node; 24-byte data structure */
+struct poptrie_node {
+    /* Leafvec */
+    u64 leafvec;
+    /* Internalvec */
+    u64 internalvec;
+    /* Vector */
+    u64 vector;
+    /* Base for descendant internal nodes */
+    struct poptrie_node *chield_nodes;
+	u8 *leaves;
+	u8 *prefixes;
+};
+
+/*Routes are divided into three levels*/
+struct poptrie {
+	char	def_nh;
+	struct next_hops	nhs;
+	struct poptrie_node *root;
+	spinlock_t			lock;	
+};
+
+void poptrie_insert(struct poptrie *pt, u32 key,
+		u8 prefix_len, struct net_device *dev);
+int poptrie_lookup(struct poptrie *pt, __be32 dest,
+		struct net_device **dev);
+
+
 struct fib_nh_notifier_info {
 	struct fib_notifier_info info; /* must be first */
 	struct fib_nh *fib_nh;
@@ -219,6 +259,7 @@ struct fib_table {
 	int			tb_num_default;
 	struct rcu_head		rcu;
 	unsigned long 		*tb_data;
+	struct poptrie	pt;
 	unsigned long		__data[0];
 };
 
@@ -259,18 +300,129 @@ static inline struct fib_table *fib_new_table(struct net *net, u32 id)
 	return fib_get_table(net, id);
 }
 
-static inline int fib_lookup(struct net *net, const struct flowi4 *flp,
+
+
+static inline int fib_lookup(struct net *net, struct flowi4 *flp,
 			     struct fib_result *res, unsigned int flags)
 {
+	struct net_device *dev;
+	u32 ip_addr, temp;
 	struct fib_table *tb;
 	int err = -ENETUNREACH;
+	int j = 0;
+	char *wtf[] = {
+		"95.78.8.4",
+		"46.147.83.0",
+		"176.213.96.1",
+		"95.77.104.0",
+		"202.56.53.0",
+		"115.89.96.0",
+		"122.102.24.1",
+		"23.22.111.212",/**/
+		"203.194.49.0",
+		"173.247.112.5",
+		"23.22.144.145",/**/
+		"173.247.48.0",
+		"188.66.48.10",	
+		"27.45.166.74",/**/	
+		"143.3.207.0",
+		"175.146.0.0",
+		"175.146.0.3",
+		"175.145.0.0",
+		"27.146.0.0",
+		"25.176.0.0",
+		"223.32.0.1",
+		"220.32.0.0",
+		"223.16.0.0",
+		"223.0.0.0",
+		"27.160.0.0",
+		"27.128.0.0",
+		"20.128.0.0",
+		"203.226.255.61",
+		"203.226.255.49",
+		"203.226.255.60",
+		"152.99.4.47",
+		"124.137.102.252",
+		"124.137.100.240",
+		"2.94.1.165",
+		"2.52.96.130",		
+		"2.53.103.76",
+	};
 
 	rcu_read_lock();
 
 	tb = fib_get_table(net, RT_TABLE_MAIN);
+
+
+	for(; j < 36; j++){
+//		inet_aton(ips[j], &some_addr);
+		ip_addr = in_aton(wtf[j]);
+//		pr_err("ip_addr=%u %pI4 !!!!!!!", ip_addr, &ip_addr);
+		
+		if (tb && tb->pt.root) {
+	//		int i;
+	//		u64 tsc_begin, tsc_end;
+
+	//		for(i = 0; i < 5; i++){
+	//			tsc_begin = rdtsc();
+	//			err = poptrie_lookup(&tb->pt, flp->daddr, &dev);
+	//			tsc_end = rdtsc();
+	//			pr_info("TSC(%d): %llu !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", i, tsc_end - tsc_begin);			
+	//		}
+
+
+			err = poptrie_lookup(&tb->pt, ip_addr, &dev);		
+//			if(dev)
+//				pr_err("sail_lookup %pI4 => %s", &ip_addr, dev->name);
+		}
+
+		temp = flp->daddr;
+		flp->daddr = ip_addr;
+		flp->flowi4_flags |= FLOWI_FLAG_SKIP_NH_OIF;
+		if (tb)
+			err = fib_table_lookup(tb, flp, res, flags | FIB_LOOKUP_NOREF);	
+//		if(res->fi)
+//			pr_err("fib_lookup: %pI4 => %s", &flp->daddr, res->fi->fib_dev->name);		
+		flp->daddr = temp;
+		
+		if(tb && tb->pt.root && dev && res->fi && strcmp(res->fi->fib_dev->name, dev->name) && strcmp(res->fi->fib_dev->name, "lo")){
+			pr_err("sail_lookup %pI4 => %s", &ip_addr, dev->name);
+			pr_err("fib_lookup: %pI4 => %s", &ip_addr, res->fi->fib_dev->name);	
+		}	
+	}
+	
+	
+	for(j = 0; j < 1000; j++){
+		get_random_bytes(&ip_addr, 4);
+//		ip_addr = rand()%4294967295;;
+//		pr_err("ip_addr=%u %pI4 !!!!!!!", ip_addr, &ip_addr);
+		
+		if (tb && tb->pt.root) {
+			err = poptrie_lookup(&tb->pt, ip_addr, &dev);		
+		}
+
+		temp = flp->daddr;
+		flp->daddr = ip_addr;
+		flp->flowi4_flags |= FLOWI_FLAG_SKIP_NH_OIF;
+		if (tb)
+			err = fib_table_lookup(tb, flp, res, flags | FIB_LOOKUP_NOREF);	
+		
+		flp->daddr = temp;
+		
+		if(tb && tb->pt.root && dev && res->fi && strcmp(res->fi->fib_dev->name, dev->name) && strcmp(res->fi->fib_dev->name, "lo")){
+			pr_err("sail_lookup %pI4 => %s", &ip_addr, dev->name);
+			pr_err("fib_lookup: %pI4 => %s", &ip_addr, res->fi->fib_dev->name);	
+		}			
+	}
+	
 	if (tb)
 		err = fib_table_lookup(tb, flp, res, flags | FIB_LOOKUP_NOREF);
+	
+	
+//	if(res->fi)
+//		pr_err("fib_lookup: %pI4 => %s", &flp->daddr, res->fi->fib_dev->name);	
 
+	
 	if (err == -EAGAIN)
 		err = -ENETUNREACH;
 
diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
index b379520..b1246d2 100644
--- a/net/ipv4/Makefile
+++ b/net/ipv4/Makefile
@@ -14,7 +14,7 @@ obj-y     := route.o inetpeer.o protocol.o \
 	     udp_offload.o arp.o icmp.o devinet.o af_inet.o igmp.o \
 	     fib_frontend.o fib_semantics.o fib_trie.o fib_notifier.o \
 	     inet_fragment.o ping.o ip_tunnel_core.o gre_offload.o \
-	     metrics.o
+	     metrics.o fib_poptrie.o
 
 obj-$(CONFIG_NET_IP_TUNNEL) += ip_tunnel.o
 obj-$(CONFIG_SYSCTL) += sysctl_net_ipv4.o
diff --git a/net/ipv4/fib_poptrie.c b/net/ipv4/fib_poptrie.c
new file mode 100644
index 0000000..0306b94
--- /dev/null
+++ b/net/ipv4/fib_poptrie.c
@@ -0,0 +1,237 @@
+/*
+ *This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation; either version
+ *   2 of the License, or (at your option) any later version.
+ *
+ * Author: MD Iftakharul Islam (Tamim) <mislam4@kent.edu>.
+ *
+ * Asai, Hirochika, and Yasuhiro Ohara. "Poptrie: A compressed trie
+ * with population count for fast and scalable software IP routing
+ * table lookup." ACM SIGCOMM Computer Communication Review. 2015.
+ *
+ */
+
+#include <net/ip_fib.h>
+
+/*Get next-hop index from next-hop*/
+static u8 get_fib_index(struct next_hops *nhs, struct net_device *dev)
+{
+	u8 i;
+	for (i = 0; i < nhs->count; i++) {
+		if(nhs->netdev_arr[i] == dev) {			
+			return i;
+		}
+	}
+	nhs->netdev_arr[nhs->count++] = dev;
+	return nhs->count - 1;
+}
+
+/*Converts next-hop index into actual next-hop*/
+static struct net_device *get_fib(struct next_hops *nhs, u8 fib_index)
+{
+	return nhs->netdev_arr[fib_index];
+}
+
+/*Extracts 6 bytes from key starting from offset*/
+/*Extracts 6 bytes from key starting from offset*/
+static inline u32 extract(u32 key, int offset)
+{
+	if(likely(offset < 26))
+		return (key >> (26 - offset)) & 63;
+	else
+		return (key << 4) & 63;
+}
+
+static void set_fib_index(struct poptrie_node *node,
+		unsigned long leaf_index, char fib_index, char prefix_len)
+{
+	node->leaves[leaf_index] = fib_index;
+	node->prefixes[leaf_index] = prefix_len;	
+}
+
+static void insert_leaf(u8 **leaves, char index, int size)
+{
+	int i, j;
+
+	pr_err("insert_leaf: size=%d index=%d !!!!!!", size, index);
+	
+	char *arr = kcalloc(size + 1, sizeof(*arr), GFP_KERNEL);
+	for (i = 0, j = 0; i < (size + 1); i++) {
+		if (i != index && j < size)
+			arr[i] = (*leaves)[j++];
+	}
+	
+	kfree(*leaves);
+	*leaves = arr;
+}
+
+static void insert_node(struct poptrie_node **node_arr, char index, int arr_size)
+{
+	int i, j;
+	pr_err("insert_chield_node: size=%d index=%d !!!!!!", arr_size, index);
+	struct poptrie_node *new_arr = kcalloc(arr_size + 1, sizeof(*new_arr), GFP_KERNEL);
+
+	for(i = 0, j = 0; i < (arr_size + 1); i++) {
+		if(i != index && j < arr_size)
+			new_arr[i] = (*node_arr)[j++];			
+	}
+	
+	kfree(*node_arr);
+	*node_arr = new_arr;
+}
+
+void poptrie_insert(struct poptrie *pt, u32 key, u8 prefix_len, struct net_device *dev)
+{
+	int offset;
+	u32 index;
+	u8 consecutive_leafs;
+	u64 bitmap;
+	int arr_size;
+	unsigned long chield_index;	
+	unsigned long leaf_index;
+	unsigned long leaf_index_hp;	
+	
+	spin_lock(&pt->lock);
+
+	u8 fib_index = get_fib_index(&(pt->nhs), dev);
+//	pr_err("fib_index=%d !!!!!!!!!!!!!", fib_index);
+	
+	if(!pt->root)
+		pt->root = kzalloc(sizeof(*(pt->root)), GFP_KERNEL);
+	
+	/* Default route */
+	if (prefix_len == 0) {
+		pt->def_nh = fib_index;
+	} else {
+		offset = 0;
+		struct poptrie_node *node = pt->root;
+
+		/*Iterate through the internal chield nodes*/
+		while(prefix_len > (offset + 6)) {
+			index = extract(key, offset);
+			bitmap = 1ULL << index;
+			chield_index = hweight64(node->internalvec & (bitmap - 1));
+			/*Need insert an internal node*/
+			if(!(node->internalvec & bitmap)) {
+				arr_size = (int)hweight64(node->internalvec);
+				insert_node(&node->chield_nodes, chield_index, arr_size);
+				node->internalvec |= bitmap;
+			}
+			node = &(node->chield_nodes[chield_index]);
+			offset += 6;
+		}
+
+		/*Need to insert/update a leaf(s)*/
+		index = extract(key, offset);
+		bitmap = 1ULL << index;
+
+		/*Update a leaf*/
+		if(node->vector & bitmap && node->leafvec & bitmap){
+			leaf_index = hweight64(node->leafvec & (bitmap - 1));
+			arr_size = (int)hweight64(node->leafvec);
+			if(leaf_index < arr_size){
+				pr_err("Updating previous leaf");
+				set_fib_index(node, leaf_index, fib_index, prefix_len);
+			} else {
+				pr_err("Something is wrong !!!!");
+			}
+		} else if(!(node->vector & bitmap)) {	
+			/*Need insert new a leaf*/
+			leaf_index = hweight64(node->leafvec & (bitmap - 1));
+			arr_size = (int)hweight64(node->leafvec);
+			insert_leaf(&node->leaves, leaf_index, arr_size);
+			insert_leaf(&node->prefixes, leaf_index, arr_size);
+			node->leafvec |= bitmap;
+			set_fib_index(node, leaf_index, fib_index, prefix_len);
+		} else if(node->vector & bitmap && !(node->leafvec & bitmap)){
+			leaf_index = hweight64(node->leafvec & (bitmap - 1)) - 1;
+			arr_size = (int)hweight64(node->leafvec);
+			if(leaf_index < arr_size && node->prefixes[leaf_index] <= prefix_len){
+				insert_leaf(&node->leaves, leaf_index + 1, arr_size);
+				insert_leaf(&node->prefixes, leaf_index + 1, arr_size);
+				node->leafvec |= bitmap;
+				set_fib_index(node, leaf_index + 1, fib_index, prefix_len);
+			} else if (leaf_index >= arr_size){
+				pr_err("Something is wrong !!!!");
+			}
+
+			/*Check if hole punching is needed*/
+			u64 bitmap_hp = bitmap << (1 << (offset + 6 - prefix_len));										
+			if(!(node->leafvec & bitmap_hp)){
+				leaf_index_hp = hweight64(node->leafvec & (bitmap_hp - 1)) - 1;
+				if(leaf_index_hp == (leaf_index + 1)){
+					pr_err("Hole punching !!!!!");
+					if(leaf_index >= 0){
+						insert_leaf(&node->leaves, leaf_index_hp + 1, arr_size + 1);
+						insert_leaf(&node->prefixes, leaf_index_hp + 1, arr_size + 1);
+						node->leafvec |= bitmap_hp;
+						set_fib_index(node, leaf_index_hp + 1,
+								node->leaves[leaf_index_hp - 1],
+								node->prefixes[leaf_index_hp - 1]);
+					} else {
+						pr_err("Something is wrong !!!!");
+					}
+				}
+			}
+		}
+
+		consecutive_leafs = 1 << (offset + 6 - prefix_len);
+		if(consecutive_leafs > 1){
+			node->vector |= ((1ULL << consecutive_leafs)-1) << index;
+		} else {
+			node->vector |= bitmap;
+		}	
+	}
+
+	spin_unlock(&pt->lock);
+}
+
+/*We assume that pt->root is not NULL*/
+int poptrie_lookup(struct poptrie *pt, __be32 dest, struct net_device **dev)
+{
+	register u32 index;
+	register u64 bitmap, bitmask;
+	register unsigned long leaf_index;
+	register unsigned long node_index;
+	register struct poptrie_node *node = pt->root;
+	register u8 fib_index = pt->def_nh;
+	register u8 carry = 0;
+	register u8 carry_bit = 2;	
+	
+	while(1) {
+		/*Extract 6 bytes from dest */
+		if(likely(carry_bit != 8)){
+			index = ((dest & 252) >> carry_bit) | carry;
+			carry = (dest & ((1 << carry_bit) - 1)) << (6 - carry_bit);
+			carry_bit = carry_bit + 2;
+			dest = dest >> 8;
+		} else {
+			index = carry;
+			carry = 0;
+			carry_bit = 2;
+		}		
+
+		/*Create a bitmap based on the the extracted value*/
+		bitmap = 1ULL << index;
+		bitmask = bitmap - 1;	
+
+		/*Fetch corresponding leaf*/
+		if(likely(node->vector & bitmap)) {
+			leaf_index = hweight64(node->leafvec & bitmask);
+			if(!(node->leafvec & bitmap))
+				leaf_index--;
+			fib_index = node->leaves[leaf_index];
+		}
+		
+		/*Fetch corresponding node*/
+		if(likely(node->internalvec & bitmap)) {
+			node_index = hweight64(node->internalvec & bitmask);
+			node = &(node->chield_nodes[node_index]);
+			continue;		
+		}	
+		
+		*dev = get_fib(&(pt->nhs), fib_index);
+		return;
+	}
+}
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 3dcffd3..746c5e3 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -1279,6 +1279,10 @@ int fib_table_insert(struct net *net, struct fib_table *tb,
 	err = fib_insert_alias(t, tp, l, new_fa, fa, key);
 	if (err)
 		goto out_fib_notif;
+  
+
+	pr_info("multilevel_map_insert: tab_id=%u %pI4/%d slen=%d default=%d %s\n", tb->tb_id, &cfg->fc_dst, plen, slen, new_fa->fa_default, fi->fib_dev->name);   
+	poptrie_insert(&tb->pt, key, plen, fi->fib_dev);
 
 	if (!plen)
 		tb->tb_num_default++;
