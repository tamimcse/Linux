diff --git a/arch/x86/configs/x86_64_defconfig b/arch/x86/configs/x86_64_defconfig
index 0f7a27f..f9a1e7b 100644
--- a/arch/x86/configs/x86_64_defconfig
+++ b/arch/x86/configs/x86_64_defconfig
@@ -896,4 +896,4 @@ CONFIG_IRQ_FORCED_THREADING=y
 #CONFIG_MK8=y
 #Following are generated by default, so change it if appropiate 
 #CONFIG_X86_L1_CACHE_SHIFT=7 
-
+CONFIG_FIB_POPTRIE=y
diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h
index 81d0f21..99709d2 100644
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@ -25,6 +25,8 @@
 #include <linux/percpu.h>
 #include <linux/notifier.h>
 #include <linux/refcount.h>
+#include <linux/net.h>
+#include <linux/inet.h>
 
 struct fib_config {
 	u8			fc_dst_len;
@@ -197,6 +199,45 @@ struct fib_entry_notifier_info {
 	u32 tb_id;
 };
 
+#if IS_ENABLED(CONFIG_FIB_POPTRIE)
+/*
+ * The router can have upto 255 ports. This limitation
+ * allows us to represent fib_index as u8
+ */
+#define NEXT_HOP_MAX 255
+
+struct next_hops {
+	struct net_device	*netdev_arr[NEXT_HOP_MAX];
+	/*Total number of next-hops*/
+	u8 count;
+};
+
+struct poptrie_node {
+	u64 vector;
+	u64 leafvec;
+	u64 nodevec;
+	struct poptrie_node *child_nodes;
+	u8 *leaves;
+	u8 *prefixes;
+	struct rcu_head		rcu;
+};
+
+struct poptrie {
+	char	def_nh;
+	struct next_hops	nhs;
+	struct poptrie_node __rcu *root;
+	spinlock_t			lock;
+};
+
+int poptrie_insert(struct poptrie *pt, u32 key,
+		u8 prefix_len, struct net_device *dev);
+int poptrie_delete(struct poptrie *pt, u32 key,
+		u8 prefix_len);
+int poptrie_flush(struct poptrie *pt);
+int poptrie_lookup(struct poptrie *pt, __be32 dest,
+		struct net_device **dev);
+#endif
+
 struct fib_nh_notifier_info {
 	struct fib_notifier_info info; /* must be first */
 	struct fib_nh *fib_nh;
@@ -219,6 +260,9 @@ struct fib_table {
 	int			tb_num_default;
 	struct rcu_head		rcu;
 	unsigned long 		*tb_data;
+#if IS_ENABLED(CONFIG_FIB_POPTRIE)
+	struct poptrie	pt;
+#endif
 	unsigned long		__data[0];
 };
 
@@ -259,15 +303,171 @@ static inline struct fib_table *fib_new_table(struct net *net, u32 id)
 	return fib_get_table(net, id);
 }
 
-static inline int fib_lookup(struct net *net, const struct flowi4 *flp,
+
+
+static inline int fib_lookup(struct net *net, struct flowi4 *flp,
 			     struct fib_result *res, unsigned int flags)
 {
+
+	u32 ip_addr, temp;
 	struct fib_table *tb;
 	int err = -ENETUNREACH;
+	int j = 0;
 
 	rcu_read_lock();
 
 	tb = fib_get_table(net, RT_TABLE_MAIN);
+
+#if IS_ENABLED(CONFIG_FIB_POPTRIE)
+	 static const char * const wtf[] = {
+		"95.78.8.4",
+		"46.147.83.0",
+		"176.213.96.1",
+		"95.77.104.0",
+		"202.56.53.0",
+		"115.89.96.0",
+		"122.102.24.1",
+		"23.22.111.212",
+		"203.194.49.0",
+		"173.247.112.5",
+		"23.22.144.145",
+		"173.247.48.0",
+		"188.66.48.10",
+		"27.45.166.74",
+		"143.3.207.0",
+		"175.146.0.0",
+		"175.146.0.3",
+		"175.145.0.0",
+		"27.146.0.0",
+		"25.176.0.0",
+		"223.32.0.1",
+		"220.32.0.0",
+		"223.16.0.0",
+		"223.0.0.0",
+		"203.33.186.250",
+		"27.160.0.0",
+		"27.128.0.0",
+		"20.128.0.0",
+		"203.226.255.61",
+		"203.226.255.49",
+		"203.226.255.60",
+		"152.99.4.47",
+		"124.137.102.252",
+		"124.137.100.240",
+		"2.94.1.165",
+		"2.52.96.130",
+		"2.53.103.76",
+		"32.211.62.211",
+		"27.251.66.158",
+		"32.243.228.88",
+		"32.191.106.198",
+		"8.87.189.26",
+		"8.177.203.8",
+		"8.203.73.108",
+		"24.23.43.245",
+		"24.22.50.154",
+		"24.104.156.0",
+		"24.104.156.1",
+		"24.104.151.2",
+		"60.0.0.3",
+		"60.244.93.218",
+		"58.68.133.37",
+		"14.66.147.199",
+		"15.63.7.51",
+		"15.18.35.189",
+		"64.254.27.242",
+		"64.254.27.8",
+		"64.254.27.234",
+		"64.87.55.185",
+		"24.123.93.189",
+		"24.123.91.191",
+		"24.106.95.125",
+		"24.106.95.243",
+		"24.106.95.192",
+		"24.106.95.90",
+		"16.3.110.176",
+		"16.111.221.8",
+		"16.102.86.234",
+		"16.251.110.31",
+		"16.90.156.79",
+		"16.76.252.91",
+		"16.102.86.234",
+		"60.194.233.156",
+		"66.243.187.157",
+		"66.243.187.197",
+		"66.199.31.185",
+		"66.199.31.140",
+		"66.147.219.46",
+		"78.24.215.246",
+		"78.24.214.248",
+		"90.188.31.245",
+		"144.243.215.191",
+		"144.243.215.127",
+		"2.91.97.138",
+		/*
+		 *"169.254.221.211",
+		 *"169.254.231.253",
+		 */
+	};
+	struct net_device *dev;
+	u64 tsc_begin, tsc_end;
+
+	for (j = 0; j < 84; j++) {
+		/*inet_aton(ips[j], &some_addr);*/
+		ip_addr = in_aton(wtf[j]);
+		/*pr_err("ip_addr=%u %pI4 !!!!!!!", ip_addr, &ip_addr);*/
+
+		if (tb && tb->pt.root) {
+			tsc_begin = rdtsc();
+			poptrie_lookup(&tb->pt, ip_addr, &dev);
+			tsc_end = rdtsc();
+		}
+
+		temp = flp->daddr;
+		flp->daddr = ip_addr;
+		flp->flowi4_flags |= FLOWI_FLAG_SKIP_NH_OIF;
+		if (tb)
+			err = fib_table_lookup(tb, flp, res,
+					       flags | FIB_LOOKUP_NOREF);
+		if (res->fi)
+			pr_err("lookup_cost: %pI4=>%s depth=%d TSC=%llu",
+				   &flp->daddr, res->fi->fib_dev->name,
+				   res->prefixlen, tsc_end - tsc_begin);
+		flp->daddr = temp;
+
+		if (tb && tb->pt.root && dev && res->fi &&
+				strcmp(res->fi->fib_dev->name, dev->name) &&
+				strcmp(res->fi->fib_dev->name, "lo")) {
+			pr_err("sail_lookup %pI4 => %s", &ip_addr, dev->name);
+			pr_err("fib_lookup: %pI4 => %s", &ip_addr,
+			        res->fi->fib_dev->name);
+		}
+	}
+
+	for (j = 1000; j < 1000; j++) {
+		get_random_bytes(&ip_addr, 4);
+
+		if (tb && tb->pt.root)
+			poptrie_lookup(&tb->pt, ip_addr, &dev);
+
+		temp = flp->daddr;
+		flp->daddr = ip_addr;
+		flp->flowi4_flags |= FLOWI_FLAG_SKIP_NH_OIF;
+		if (tb)
+			err = fib_table_lookup(tb, flp,
+					       res, flags | FIB_LOOKUP_NOREF);
+
+		flp->daddr = temp;
+
+		if (tb && tb->pt.root && dev && res->fi &&
+		    strcmp(res->fi->fib_dev->name, dev->name) &&
+		    strcmp(res->fi->fib_dev->name, "lo")) {
+			pr_err("sail_lookup %pI4 => %s", &ip_addr, dev->name);
+			pr_err("fib_lookup: %pI4 => %s",
+			        &ip_addr, res->fi->fib_dev->name);
+		}
+	}
+#endif
 	if (tb)
 		err = fib_table_lookup(tb, flp, res, flags | FIB_LOOKUP_NOREF);
 
diff --git a/net/ipv4/Kconfig b/net/ipv4/Kconfig
index 80dad30..aac1431 100644
--- a/net/ipv4/Kconfig
+++ b/net/ipv4/Kconfig
@@ -52,6 +52,15 @@ config IP_ADVANCED_ROUTER
 
 	  If unsure, say N here.
 
+config FIB_POPTRIE
+	bool "FIB POPTRIE"
+	help
+	  This will store FIB table as a Poptrie (along with LC-trie). This is
+	  useful if you want fast routing table lookup in XDP forwarding.
+	  XDP along with fast routing table lookup will enable Linux to work as
+	  a carrier router (similar to DPDK/VPP based routers).
+	  Currently this option only supports up to 255 ports.
+
 config IP_FIB_TRIE_STATS
 	bool "FIB TRIE statistics"
 	depends on IP_ADVANCED_ROUTER
diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
index b379520..fae4bd4 100644
--- a/net/ipv4/Makefile
+++ b/net/ipv4/Makefile
@@ -62,6 +62,7 @@ obj-$(CONFIG_TCP_CONG_LP) += tcp_lp.o
 obj-$(CONFIG_TCP_CONG_YEAH) += tcp_yeah.o
 obj-$(CONFIG_TCP_CONG_ILLINOIS) += tcp_illinois.o
 obj-$(CONFIG_NETLABEL) += cipso_ipv4.o
+obj-$(CONFIG_FIB_POPTRIE) += fib_poptrie.o
 
 obj-$(CONFIG_XFRM) += xfrm4_policy.o xfrm4_state.o xfrm4_input.o \
 		      xfrm4_output.o xfrm4_protocol.o
diff --git a/net/ipv4/fib_poptrie.c b/net/ipv4/fib_poptrie.c
new file mode 100644
index 0000000..4fce766
--- /dev/null
+++ b/net/ipv4/fib_poptrie.c
@@ -0,0 +1,496 @@
+// SPDX-License-Identifier: GPL-2.0
+/*This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation; either version
+ *   2 of the License, or (at your option) any later version.
+ *
+ * Author: MD Iftakharul Islam (Tamim) <mislam4@kent.edu>.
+ *
+ * Asai, Hirochika, and Yasuhiro Ohara. "Poptrie: A compressed trie
+ * with population count for fast and scalable software IP routing
+ * table lookup." ACM SIGCOMM Computer Communication Review. 2015.
+ *
+ */
+
+#include <net/ip_fib.h>
+
+/*Get next-hop index from next-hop*/
+static u8 get_fib_index(struct next_hops *nhs, struct net_device *dev)
+{
+	u8 i;
+
+	for (i = 0; i < nhs->count; i++) {
+		if (nhs->netdev_arr[i] == dev)
+			return i;
+	}
+	nhs->netdev_arr[nhs->count++] = dev;
+	return nhs->count - 1;
+}
+
+/*Extracts 6 bytes from key starting from offset*/
+static u32 extract(u32 key, int offset)
+{
+	if (likely(offset < 26))
+		return (key >> (26 - offset)) & 63;
+	else
+		return (key << 4) & 63;
+}
+
+/*Set FIB index and prefix length to a leaf*/
+static void set_fib_index(struct poptrie_node *node,
+			  unsigned long leaf_index,
+			  char fib_index, char prefix_len)
+{
+	node->leaves[leaf_index] = fib_index;
+	node->prefixes[leaf_index] = prefix_len;
+}
+
+/*Insert a leaf at index*/
+static bool insert_leaf(struct poptrie_node *node,
+			char index, char fib_index,
+			char prefix_len)
+{
+	int i, j;
+	char *leaves;
+	char *prefixes;
+	int size = (int)hweight64(node->leafvec);
+
+	if (index > size) {
+		pr_err("Index needs to be smaller or equal to size");
+		return false;
+	}
+
+	leaves = kcalloc(size + 1, sizeof(*leaves), GFP_ATOMIC);
+	prefixes = kcalloc(size + 1, sizeof(*prefixes), GFP_ATOMIC);
+
+	for (i = 0, j = 0; i < (size + 1); i++) {
+		if (i == index) {
+			leaves[i] = fib_index;
+			prefixes[i] = prefix_len;
+		} else {
+			leaves[i] = node->leaves[j];
+			prefixes[i] = node->prefixes[j];
+			j++;
+		}
+	}
+
+	kfree(node->leaves);
+	kfree(node->prefixes);
+	node->leaves = leaves;
+	node->prefixes = prefixes;
+	return true;
+}
+
+/*Insert a new node at index*/
+static void insert_chield_node(struct poptrie_node *node,
+			       char index)
+{
+	int i, j;
+	struct poptrie_node *arr;
+	int arr_size  = (int)hweight64(node->nodevec);
+
+	arr = kcalloc(arr_size + 1, sizeof(*arr), GFP_ATOMIC);
+	for (i = 0, j = 0; i < (arr_size + 1); i++) {
+		if (i != index && j < arr_size)
+			arr[i] = node->child_nodes[j++];
+	}
+
+	kfree(node->child_nodes);
+	node->child_nodes = arr;
+}
+
+/*Delete a leaf at index*/
+static bool delete_leaf(struct poptrie_node *node,
+			char index)
+{
+	int i, j;
+	char *leaves;
+	char *prefixes;
+	int size = (int)hweight64(node->leafvec);
+
+	if (index >= size) {
+		pr_err("Index needs to be smaller or equal to size");
+		return false;
+	}
+
+	leaves = kcalloc(size - 1, sizeof(*leaves), GFP_ATOMIC);
+	prefixes = kcalloc(size - 1, sizeof(*prefixes), GFP_ATOMIC);
+
+	for (i = 0, j = 0; i < size; i++) {
+		if (i != index) {
+			leaves[j] = node->leaves[i];
+			prefixes[j] = node->prefixes[i];
+			j++;
+		}
+	}
+
+	kfree(node->leaves);
+	kfree(node->prefixes);
+	node->leaves = leaves;
+	node->prefixes = prefixes;
+	return true;
+}
+
+int poptrie_insert(struct poptrie *pt, u32 key,
+		   u8 prefix_len, struct net_device *dev)
+{
+	int offset, i;
+	u32 index;
+	u8 consecutive_leafs;
+	u64 bitmap;
+	u64 bitmap_hp;
+	int arr_size;
+	unsigned long chield_index;
+	unsigned long leaf_index, prev_leaf_index;
+	unsigned long index_hp;
+	struct poptrie_node *node;
+	u8 prev_fib_index, prev_prefix_len;
+	u8 fib_index = get_fib_index(&pt->nhs, dev);
+
+	spin_lock(&pt->lock);
+
+	node = rcu_dereference(pt->root);
+	if (!node) {
+		node = kzalloc(sizeof(*node), GFP_ATOMIC);
+		rcu_assign_pointer(pt->root, node);
+	}
+
+	/* Default route */
+	if (prefix_len == 0) {
+		pt->def_nh = fib_index;
+		goto finish;
+	}
+
+	/*Iterate through the nodes*/
+	offset = 0;
+	while (prefix_len > (offset + 6)) {
+		index = extract(key, offset);
+		bitmap = 1ULL << index;
+		chield_index = hweight64(node->nodevec & (bitmap - 1));
+
+		/*No node for this index, so need to insert a node*/
+		if (!(node->nodevec & bitmap)) {
+			insert_chield_node(node, chield_index);
+			node->nodevec |= bitmap;
+		}
+		node = &node->child_nodes[chield_index];
+		offset += 6;
+	}
+
+	/*Now need to insert a leaf*/
+
+	index = extract(key, offset);
+	bitmap = 1ULL << index;
+	consecutive_leafs = 1 << (offset + 6 - prefix_len);
+
+	if (node->vector & bitmap && node->leafvec & bitmap) {
+		/*A leaf already exist for this index,
+		 *so update the existing leaf
+		 */
+		leaf_index = hweight64(node->leafvec & (bitmap - 1));
+		arr_size = (int)hweight64(node->leafvec);
+		if (leaf_index >= arr_size)
+			goto error;
+		/*Ignore the prefix*/
+		if (node->prefixes[leaf_index] > prefix_len) {
+			goto finish;
+		} else if (node->prefixes[leaf_index] == prefix_len) {
+			set_fib_index(node, leaf_index, fib_index, prefix_len);
+		} else {
+			/*hole punching*/
+			bitmap_hp = bitmap << consecutive_leafs;
+			if (!(node->leafvec & bitmap_hp)) {
+				index_hp = hweight64(node->leafvec &
+						     (bitmap_hp - 1)) - 1;
+				if (node->prefixes[index_hp] <= prefix_len) {
+					insert_leaf(node, index_hp,
+						    fib_index, prefix_len);
+					node->leafvec |= bitmap_hp;
+				}
+
+				for (i = leaf_index; i < index_hp ; i++) {
+					if (node->prefixes[i] <= prefix_len)
+						set_fib_index(node, i,
+							      fib_index,
+							      prefix_len);
+				}
+			} else {
+				index_hp = hweight64(node->leafvec &
+						     (bitmap_hp - 1)) - 1;
+				for (i = leaf_index; i <= index_hp ; i++) {
+					if (node->prefixes[i] <= prefix_len)
+						set_fib_index(node, i,
+							      fib_index,
+							      prefix_len);
+				}
+			}
+		}
+	} else if (!(node->vector & bitmap)) {
+		/*No leaf for this index, so need to insert a leaf*/
+		leaf_index = hweight64(node->leafvec & (bitmap - 1));
+		insert_leaf(node, leaf_index, fib_index, prefix_len);
+		node->leafvec |= bitmap;
+	} else if (node->vector & bitmap && !(node->leafvec & bitmap)) {
+		/*There is a leaf for this index created by another
+		 *  prefix with smaller length
+		 */
+		prev_leaf_index = hweight64(node->leafvec & (bitmap - 1)) - 1;
+		arr_size = (int)hweight64(node->leafvec);
+		if (prev_leaf_index >= arr_size)
+			goto error;
+		if (node->prefixes[prev_leaf_index] <= prefix_len) {
+			insert_leaf(node, prev_leaf_index + 1,
+				    fib_index, prefix_len);
+			node->leafvec |= bitmap;
+		}
+
+		/*hole punching*/
+		prev_fib_index = node->leaves[prev_leaf_index];
+		prev_prefix_len = node->prefixes[prev_leaf_index];
+
+		bitmap_hp = bitmap << consecutive_leafs;
+		if (!(node->leafvec & bitmap_hp)) {
+			index_hp = hweight64(node->leafvec &
+					     (bitmap_hp - 1)) - 1;
+			if (node->prefixes[index_hp] <= prefix_len) {
+				if (prev_leaf_index < 0)
+					goto error;
+				insert_leaf(node, index_hp + 1,
+					    prev_fib_index, prev_prefix_len);
+				node->leafvec |= bitmap_hp;
+			}
+		}
+
+		for (i = 2; i < consecutive_leafs; i++) {
+			bitmap_hp = bitmap << (i - 1);
+			if (node->leafvec & bitmap_hp) {
+				index_hp = hweight64(node->leafvec &
+						     (bitmap_hp - 1)) - 1;
+				insert_leaf(node, index_hp + 1,
+					    fib_index, prefix_len);
+				node->leafvec |= bitmap_hp;
+			}
+		}
+	}
+
+	if (consecutive_leafs > 1)
+		node->vector |= ((1ULL << consecutive_leafs) - 1) << index;
+	else
+		node->vector |= bitmap;
+
+	goto finish;
+
+error:
+	pr_err("Something is very wrong !!!!");
+finish:
+	spin_unlock(&pt->lock);
+	return 0;
+}
+
+int poptrie_delete(struct poptrie *pt, u32 key,
+		   u8 prefix_len)
+{
+	int offset, i;
+	u32 index;
+	u8 consecutive_leafs;
+	u64 bitmap;
+	int arr_size;
+	unsigned long chield_index;
+	unsigned long leaf_index;
+	struct poptrie_node *node;
+	bool update_vector = true;
+
+	spin_lock(&pt->lock);
+
+	node = rcu_dereference(pt->root);
+
+	if (!node || prefix_len == 0)
+		goto finish;
+
+	/*Iterate through the nodes*/
+	offset = 0;
+	while (prefix_len > (offset + 6)) {
+		index = extract(key, offset);
+		bitmap = 1ULL << index;
+		chield_index = hweight64(node->nodevec & (bitmap - 1));
+		/*No node for this index*/
+		if (!(node->nodevec & bitmap))
+			goto finish;
+		node = &node->child_nodes[chield_index];
+		offset += 6;
+	}
+
+	/*Now need to delete the leaf*/
+
+	index = extract(key, offset);
+	bitmap = 1ULL << index;
+	consecutive_leafs = 1 << (offset + 6 - prefix_len);
+
+	/*The prefix does not exist*/
+	if (!(node->vector & bitmap) || !(node->leafvec & bitmap))
+		goto finish;
+
+	leaf_index = hweight64(node->leafvec & (bitmap - 1));
+	arr_size = (int)hweight64(node->leafvec);
+	if (leaf_index >= arr_size)
+		goto error;
+
+	/*The prefix-length does not match*/
+	if (node->prefixes[leaf_index] != prefix_len)
+		goto finish;
+
+	/*Check if this prefix will replaced
+	 * by another prefix with smaller length
+	 */
+	for (i = leaf_index - 1; i >= 0; i--) {
+		if (node->prefixes[leaf_index] < prefix_len) {
+			update_vector = false;
+			break;
+		}
+	}
+
+	if (update_vector) {
+		if (consecutive_leafs > 1)
+			node->vector &=
+				 ~(((1ULL << consecutive_leafs) - 1) << index);
+		else
+			node->vector &= ~bitmap;
+	}
+
+	if (consecutive_leafs > 1) {
+		for (i = 0; i < consecutive_leafs; i++) {
+			if ((node->leafvec & bitmap) &&
+			    node->prefixes[leaf_index] == prefix_len) {
+				delete_leaf(node, leaf_index);
+				node->leafvec &= ~bitmap;
+			}
+			bitmap <<= 1;
+			leaf_index = hweight64(node->leafvec & (bitmap - 1));
+		}
+	} else {
+		delete_leaf(node, leaf_index);
+		node->leafvec &= ~bitmap;
+	}
+
+	goto finish;
+error:
+	pr_err("Something is very wrong !!!!");
+finish:
+	spin_unlock(&pt->lock);
+	return 0;
+}
+
+/*This recursive function frees all
+ * the nodes in depth-first-search fashion
+ */
+static int poptrie_node_free(struct poptrie_node *node)
+{
+	int i;
+	int child_count;
+
+	if (!node)
+		return 0;
+	child_count = hweight64(node->nodevec);
+	if (node->child_nodes) {
+		for (i = 0; i < child_count; i++)
+			poptrie_node_free(&node->child_nodes[i]);
+	}
+
+	kfree(node->leaves);
+	kfree(node->prefixes);
+	kfree(node->child_nodes);
+
+	node->leaves = NULL;
+	node->prefixes = NULL;
+	node->child_nodes = NULL;
+
+	node->vector = 0;
+	node->leafvec = 0;
+	node->nodevec = 0;
+
+	return 0;
+}
+
+static void poptrie_rcu_free(struct rcu_head *rcu)
+{
+	poptrie_node_free(container_of(rcu, struct poptrie_node, rcu));
+}
+
+int poptrie_flush(struct poptrie *pt)
+{
+	struct poptrie_node *rt = rcu_dereference(pt->root);
+
+	if (!rt)
+		return 0;
+
+	RCU_INIT_POINTER(pt->root, NULL);
+	/* Wait for all references to be released */
+	call_rcu(&rt->rcu, poptrie_rcu_free);
+	return 0;
+}
+
+int poptrie_lookup(struct poptrie *pt, __be32 dest, struct net_device **dev)
+{
+	u32 index;
+	u64 bitmap, bitmask;
+	unsigned long leaf_index;
+	unsigned long node_index;
+	struct poptrie_node *node;
+	u8 fib_index = pt->def_nh;
+	u8 carry = 0;
+	u8 carry_bit = 2;
+
+	rcu_read_lock();
+
+	node = rcu_dereference(pt->root);
+
+	if (unlikely(!node))
+		goto finish;
+
+	while (1) {
+		/*Extract 6 bytes from dest without converting
+		 * from network to host format (via ntohl). This requires
+		 * fewer CPU cycles
+		 */
+		if (likely(carry_bit != 8)) {
+			index = ((dest & 252) >> carry_bit) | carry;
+			carry = (dest & ((1 << carry_bit) - 1))
+					<< (6 - carry_bit);
+			carry_bit = carry_bit + 2;
+			dest = dest >> 8;
+		} else {
+			index = carry;
+			carry = 0;
+			carry_bit = 2;
+		}
+
+		/*Create a bitmap based on the the extracted value*/
+		bitmap = 1ULL << index;
+		bitmask = bitmap - 1;
+
+		/*Find corresponding leaf*/
+		if (likely(node->vector & bitmap)) {
+			/*hweight64 == popcnt. It counts
+			 * the number of bits set to 1
+			 */
+			leaf_index = hweight64(node->leafvec & bitmask);
+			if (!(node->leafvec & bitmap))
+				leaf_index--;
+			fib_index = node->leaves[leaf_index];
+		}
+
+		/*Find corresponding node*/
+		if (likely(node->nodevec & bitmap)) {
+			/*hweight64 == popcnt. It counts
+			 * the number of bits set to 1
+			 */
+			node_index = hweight64(node->nodevec & bitmask);
+			node = &node->child_nodes[node_index];
+			continue;
+		}
+finish:
+		*dev = pt->nhs.netdev_arr[fib_index];
+		rcu_read_unlock();
+		return 0;
+	}
+}
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 3dcffd3..a34998c 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -1280,6 +1280,10 @@ int fib_table_insert(struct net *net, struct fib_table *tb,
 	if (err)
 		goto out_fib_notif;
 
+#if IS_ENABLED(CONFIG_FIB_POPTRIE)
+	poptrie_insert(&tb->pt, key, plen, fi->fib_dev);
+#endif
+
 	if (!plen)
 		tb->tb_num_default++;
 
@@ -1564,6 +1568,10 @@ int fib_table_delete(struct net *net, struct fib_table *tb,
 
 	pr_debug("Deleting %08x/%d tos=%d t=%p\n", key, plen, tos, t);
 
+#if IS_ENABLED(CONFIG_FIB_POPTRIE)
+	poptrie_delete(&tb->pt, key, plen);
+#endif
+
 	fa_to_delete = NULL;
 	hlist_for_each_entry_from(fa, fa_list) {
 		struct fib_info *fi = fa->fa_info;
@@ -1925,6 +1933,10 @@ int fib_table_flush(struct net *net, struct fib_table *tb)
 		}
 	}
 
+#if IS_ENABLED(CONFIG_FIB_POPTRIE)
+	poptrie_flush(&tb->pt);
+#endif
+
 	pr_debug("trie_flush found=%d\n", found);
 	return found;
 }
