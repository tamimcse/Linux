diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h
index 81d0f21..14625ee 100644
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@ -197,6 +197,52 @@ struct fib_entry_notifier_info {
 	u32 tb_id;
 };
 
+#define LEVEL16_BITMAP_SIZE 65536
+#define LEVEL24_CHUNK_SIZE 256
+#define LEVEL32_CHUNK_SIZE 256
+
+struct level16 {
+	struct fib_info	*nexthops[LEVEL16_BITMAP_SIZE];
+	/*Maximum value of chunk ID is 2^16*/
+	u16				chunk_ids[LEVEL16_BITMAP_SIZE];
+	u8				prefix_lens[LEVEL16_BITMAP_SIZE];
+};
+
+struct level24 {
+	struct fib_info	**nexthops;
+	/*Maximum value of chunk ID is 2^24*/
+	u32             *chunk_ids;
+	/*
+	 * Number of total chunks is equal to number of
+	 * internal nodes on level 16
+	 */
+	u16				total_chunks;
+	u8				*prefix_lens;
+};
+
+struct level32 {
+	struct fib_info   **nexthops;
+	u8                 *prefix_lens;
+	/*
+	 * Number of total chunks is equal to
+	 * number of internal nodes on level 24
+	 */
+	u32                 total_chunks;
+};
+
+/*Routes are divided into three levels*/
+struct multilevel_map {
+	struct fib_info		*default_fib;
+	struct level16	level16;
+	struct level24	level24;
+	struct level32	level32;
+};
+
+void multilevel_map_insert(struct multilevel_map *map, u32 key,
+		u8 prefix_len, struct fib_info *fi);
+struct fib_info * multilevel_map_lookup(struct multilevel_map *map, __be32 dest_ip);
+
+
 struct fib_nh_notifier_info {
 	struct fib_notifier_info info; /* must be first */
 	struct fib_nh *fib_nh;
@@ -219,6 +265,7 @@ struct fib_table {
 	int			tb_num_default;
 	struct rcu_head		rcu;
 	unsigned long 		*tb_data;
+	struct multilevel_map	map;
 	unsigned long		__data[0];
 };
 
@@ -263,13 +310,24 @@ static inline int fib_lookup(struct net *net, const struct flowi4 *flp,
 			     struct fib_result *res, unsigned int flags)
 {
 	struct fib_table *tb;
+	struct fib_info *fi;
 	int err = -ENETUNREACH;
 
 	rcu_read_lock();
 
 	tb = fib_get_table(net, RT_TABLE_MAIN);
+
+	if (tb) {
+		fi = multilevel_map_lookup(&tb->map, flp->daddr);
+		if(fi)
+			pr_err("sail_lookup %pI4 => %s", &flp->daddr, fi->fib_dev->name);		
+	}
+
 	if (tb)
 		err = fib_table_lookup(tb, flp, res, flags | FIB_LOOKUP_NOREF);
+	
+	if(res->fi)
+		pr_err("fib_lookup: %pI4 => %s", &flp->daddr, res->fi->fib_dev->name);	
 
 	if (err == -EAGAIN)
 		err = -ENETUNREACH;
diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
index b379520..223e3ba 100644
--- a/net/ipv4/Makefile
+++ b/net/ipv4/Makefile
@@ -14,7 +14,7 @@ obj-y     := route.o inetpeer.o protocol.o \
 	     udp_offload.o arp.o icmp.o devinet.o af_inet.o igmp.o \
 	     fib_frontend.o fib_semantics.o fib_trie.o fib_notifier.o \
 	     inet_fragment.o ping.o ip_tunnel_core.o gre_offload.o \
-	     metrics.o
+	     metrics.o fib_multilevel_map.o
 
 obj-$(CONFIG_NET_IP_TUNNEL) += ip_tunnel.o
 obj-$(CONFIG_SYSCTL) += sysctl_net_ipv4.o
diff --git a/net/ipv4/fib_multilevel_map.c b/net/ipv4/fib_multilevel_map.c
new file mode 100644
index 0000000..fe638e0
--- /dev/null
+++ b/net/ipv4/fib_multilevel_map.c
@@ -0,0 +1,304 @@
+/*
+ *This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation; either version
+ *   2 of the License, or (at your option) any later version.
+ *
+ * Author: MD Iftakharul Islam (Tamim) <mislam4@kent.edu>.
+ *
+ * Yang, Tong, et al. "Guarantee IP lookup performance with FIB explosion."
+ * ACM SIGCOMM Computer Communication Review. Vol. 44. No. 4. ACM, 2014.
+ *
+ */
+
+#include <net/ip_fib.h>
+
+static void update_chunk_arr_16(u16 *chunk_ids, u32 index)
+{
+	int i;
+	/*Find the chunk_no on the left*/
+	for (i = index - 1; i >= 0; i--) {
+		/*Find the first chunk_no > 0 on the left*/
+		if (chunk_ids[i] > 0) {
+			chunk_ids[index] = chunk_ids[i] + 1;
+			break;
+		}
+	}
+
+	if (chunk_ids[index] == 0)
+		chunk_ids[index] = 1;
+
+	/* Increment chunk_no on the right */
+	for (i = index + 1; i < LEVEL16_BITMAP_SIZE; i++) {
+		if (chunk_ids[i] > 0)
+			chunk_ids[i]++;
+	}
+}
+
+static void update_chunk_arr_24(u32 *chunk_ids, u32 index, u16 total_chunks)
+{
+	int i;
+	/*Find the chunk_no on the left*/
+	for (i = index - 1; i >= 0; i--) {
+		/*Find the first chunk_no > 0 on the left*/
+		if (chunk_ids[i] > 0) {
+			chunk_ids[index] = chunk_ids[i] + 1;
+			break;
+		}
+	}
+
+	if (chunk_ids[index] == 0)
+		chunk_ids[index] = 1;
+
+	/* Increment chunk_no on the right */
+	for (i = index + 1; i < LEVEL24_CHUNK_SIZE * total_chunks; i++) {
+		if (chunk_ids[i] > 0)
+			chunk_ids[i]++;
+	}
+}
+
+/* Insert a chunk at index */
+static void bn24_chunk_insert(struct level24 *level24, u16 index)
+{
+	struct fib_info **n24;
+	u32 *c24;
+	u8 *p24;
+	int i;
+	u32 arr_size, temp;
+	int a, b, c;
+
+	++level24->total_chunks;
+	arr_size = level24->total_chunks * LEVEL24_CHUNK_SIZE;
+	n24 = kcalloc(arr_size, sizeof(*n24), GFP_KERNEL);
+	c24 = kcalloc(arr_size, sizeof(*c24), GFP_KERNEL);
+	p24 = kcalloc(arr_size, sizeof(*p24), GFP_KERNEL);
+
+	if (unlikely(!n24 || !c24 || !p24))
+		return;
+
+	/*Copy everything from 0...index-1*/
+	if (index > 1) {
+		temp = (index - 1) * LEVEL24_CHUNK_SIZE;
+		memcpy(n24, level24->nexthops, sizeof(*n24) * temp);
+		memcpy(c24, level24->chunk_ids, sizeof(*c24) * temp);
+		memcpy(p24, level24->prefix_lens, sizeof(*p24) * temp);
+	}
+
+	/*Copy everything from index....end*/
+	if (index > 1 && level24->total_chunks > index) {
+		a = index * LEVEL24_CHUNK_SIZE;
+		b = (index - 1) * LEVEL24_CHUNK_SIZE;
+		c = (level24->total_chunks - index) * LEVEL24_CHUNK_SIZE;
+		for (i = 0 ; i < c ; i++) {
+			n24[a + i] = level24->nexthops[b + i];
+			c24[a + i] = level24->chunk_ids[b + i];
+			p24[a + i] = level24->prefix_lens[b + i];
+		}
+	}
+
+	kfree(level24->nexthops);
+	kfree(level24->chunk_ids);
+	kfree(level24->prefix_lens);
+
+	level24->nexthops = n24;
+	level24->chunk_ids = c24;
+	level24->prefix_lens = p24;
+}
+
+/* Insert a chunk at (index-1) */
+static void n32_chunk_insert(struct level32 *level32, u32 index)
+{
+	struct fib_info **n32;
+	int i;
+	u8 *p32;
+	u32 arr_size, temp;
+	int a, b, c;
+
+	++level32->total_chunks;
+	arr_size = level32->total_chunks * LEVEL32_CHUNK_SIZE;
+
+	n32 = kcalloc(arr_size, sizeof(*n32), GFP_KERNEL);
+	p32 = kcalloc(arr_size, sizeof(*p32), GFP_KERNEL);
+
+	if (unlikely(!n32 || !p32))
+		return;
+
+	/*Copy everything from 0...index-1*/
+	if (index > 1) {
+		temp = (index - 1) * LEVEL32_CHUNK_SIZE;
+		memcpy(n32, level32->nexthops, sizeof(*n32) * temp);
+		memcpy(p32, level32->prefix_lens, sizeof(*p32) * temp);
+	}
+
+	/*Copy everything from index....end*/
+	if (level32->total_chunks > index) {
+		a = index * LEVEL32_CHUNK_SIZE;
+		b = (index - 1) * LEVEL32_CHUNK_SIZE;
+		c = (level32->total_chunks - index) * LEVEL32_CHUNK_SIZE;
+		for (i = 0 ; i < c ; i++) {
+			n32[a + i] = level32->nexthops[b + i];
+			p32[a + i] = level32->prefix_lens[b + i];
+		}
+	}
+
+	kfree(level32->nexthops);
+	kfree(level32->prefix_lens);
+
+	level32->nexthops = n32;
+	level32->prefix_lens = p32;
+}
+
+void multilevel_map_insert(struct multilevel_map *map, u32 key, u8 prefix_len, struct fib_info *fi)
+{
+	int i;
+	u32 index;
+	u8 j;
+	u32 chunk_offset, chunk_index;
+	int no_level;
+
+	/* Default route */
+	if (prefix_len == 0) {
+		map->default_fib = fi;
+	} else if (prefix_len <= 16) {
+		struct level16	*level16 = &map->level16;
+
+		index = key >> (32 - prefix_len);
+		if (prefix_len == 16) {
+			level16->nexthops[index] = fi;
+			level16->prefix_lens[index] = 16;
+		} else {
+			/*Level pushing*/
+			no_level = 16 - prefix_len;
+			index = index << no_level;
+			j = 1 << no_level;
+			for (i = 0; i < j; i++) {
+				/*Longer prefix exists*/
+				if (level16->prefix_lens[index + i] > prefix_len)
+					continue;
+				level16->nexthops[index + i] = fi;
+				level16->prefix_lens[index + i] = prefix_len;
+			}
+		}
+	} else if (prefix_len <= 24) {
+		struct level16	*level16 = &map->level16;
+		struct level24	*level24 = &map->level24;
+
+		index = key >> 16;
+		/* Need to create a new chunk of BN24 */
+		if (level16->chunk_ids[index] == 0) {
+			update_chunk_arr_16(level16->chunk_ids, index);
+			/* To make sure chunk_ids are updated
+			 * before using it
+			 */
+			smp_mb();
+			bn24_chunk_insert(level24, level16->chunk_ids[index]);
+		}
+
+		chunk_offset = ((level16->chunk_ids[index] - 1) << 8);
+		chunk_index = ((key << 16) >> (16 + 32 - prefix_len));
+		if (prefix_len == 24) {
+			index = chunk_offset + chunk_index;
+			level24->nexthops[index] = fi;
+			level24->prefix_lens[index] = 24;
+		} else {
+			/*Level pushing*/
+			no_level = 24 - prefix_len;
+			index = chunk_offset + (chunk_index << no_level);
+			j = 1 << no_level;
+			for (i = 0; i < j; i++) {
+				/*Longer prefix exists*/
+				if (level24->prefix_lens[index + i] > prefix_len)
+					continue;
+				level24->nexthops[index + i] = fi;
+				level24->prefix_lens[index + i] = prefix_len;
+			}
+		}
+	} else {
+		struct level16	*level16 = &map->level16;
+		struct level24	*level24 = &map->level24;
+		struct level32	*level32 = &map->level32;
+
+		/*Prefix length 25~32*/
+		index = key >> 16;
+		/* Need to create a new chunk in level 24 */
+		if (level16->chunk_ids[index] == 0) {
+			update_chunk_arr_16(level16->chunk_ids, index);
+			/* To make sure chunk_ids are updated
+			 * before using it
+			 */
+			smp_mb();
+			bn24_chunk_insert(level24, level16->chunk_ids[index]);
+		}
+
+		index = ((level16->chunk_ids[index] - 1) << 8) + ((key << 16) >> 24);
+
+		/* Need to insert a chunk in level 32 */
+		if (level24->chunk_ids[index] == 0) {
+			update_chunk_arr_24(level24->chunk_ids, index, level24->total_chunks);
+			/* To make sure chunk_ids are updated
+			 * before using it
+			 */
+			smp_mb();
+			n32_chunk_insert(level32, level24->chunk_ids[index]);
+		}
+
+		chunk_offset = (level24->chunk_ids[index] - 1) << 8;
+		chunk_index = (key & 255) >> (32 - prefix_len);
+		if (prefix_len == 32) {
+			index = chunk_offset + chunk_index;
+			level32->nexthops[index] = fi;
+			level24->prefix_lens[index] = 32;
+		} else {
+			/*Level pushing*/
+			no_level = 32 - prefix_len;
+			index = chunk_offset + (chunk_index << no_level);
+			j = 1 << no_level;
+			for (i = 0; i < j; i++) {
+				/*Longer prefix exists*/
+				if (level32->prefix_lens[index + i] > prefix_len)
+					continue;
+				level32->nexthops[index + i] = fi;
+				level32->prefix_lens[index + i] = prefix_len;
+			}
+		}
+	}
+}
+
+struct fib_info * multilevel_map_lookup(struct multilevel_map *map, __be32 dest_ip)
+{
+	int key16, key24, key32;
+	u32 daddr = ntohl(dest_ip);
+
+	key16 = daddr >> 16;
+	/*No chunk for this packet in level 24*/
+	if (map->level16.chunk_ids[key16] == 0) {
+backtrack_level_16:
+		/*Solid node found on level 16*/
+		if (map->level16.nexthops[key16])
+			return map->level16.nexthops[key16];
+		else
+			return map->default_fib;
+	}
+
+	/*lookup in level 24*/
+	key24 = ((map->level16.chunk_ids[key16] - 1) << 8)
+			+ ((daddr << 16) >> 24);
+	/*No chunk for this packet in level 32*/
+	if (map->level24.chunk_ids[key24] == 0) {
+backtrack_level_24:
+		/*Solid node found on level 24*/
+		if (map->level24.nexthops[key24])
+			return map->level24.nexthops[key24];
+		/*Otherwise backtrack*/
+		goto backtrack_level_16;
+	}
+
+	/*lookup in level 32*/
+	key32 = ((map->level24.chunk_ids[key24] - 1) << 8)
+			+ (daddr & 255);
+	/*Solid node found on level 32*/
+	if (map->level32.nexthops[key32])
+		return map->level32.nexthops[key32];
+	/*Otherwise backtrack*/
+	goto backtrack_level_24;
+}
\ No newline at end of file
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 3dcffd3..dfd27a8 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -1279,6 +1279,10 @@ int fib_table_insert(struct net *net, struct fib_table *tb,
 	err = fib_insert_alias(t, tp, l, new_fa, fa, key);
 	if (err)
 		goto out_fib_notif;
+  
+
+	pr_info("multilevel_map_insert: tab_id=%u %pI4/%d slen=%d default=%d\n", tb->tb_id, &cfg->fc_dst, plen, slen, new_fa->fa_default);   
+	multilevel_map_insert(&tb->map, key, plen, fi);
 
 	if (!plen)
 		tb->tb_num_default++;
